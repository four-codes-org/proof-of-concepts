

```json
{
  "common-encryption-mail": "jinojoe@gmail.com",
  "common-agent-name": "jinojoe",
  "common-pgp-key-bucket": "demo-sit-cp",
  "agencies": [
    {
      "jinojoe": {
        "receipt_email_address": "jinojoe@gmail.com",
        "sftp_username": "jino",
        "sftp_port": 22,
        "sftp_password": "password",
        "sftp_hostname": "s-1369b93de4224908a.server.transfer.ap-south-1.amazonaws.com",
        "sftp_encoded_private_key": "LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlKS0FJQkFBS0NBZ0VBdVBocmJ0TUkzRzdQOXFMOXVVRVhaN0JCcjFLNjZzUzJxT3QvbGJDOFNJSnVJQTRrCnhBLzZ4Vm84NDVTazhUb2k1aFc4ckl6TWVheWZLUWdjZ1lFTFRJL2kwcUxWamdkRURlTzNOV1JXTTVFN1VJTXMKbDR4Z0tFdDVnNEJRQUJjZmFrQ2Y4ZGtBaG5Ud050aFgrSElLRC9kOCtKb3h4WE4yNnBBTmhnQUkwb0RZY21UaQpoN0F0UjczbndacisvQWdMdEN4b1Rkb1VLcWo3UmhSOHk4N0RoRlMyZmlpdlV1OFY1YnNvT3hDdndxcUdwdWxtCkt5R1g5ekNVL2x6T0M4Y3VQUEw2dU1ISE1BeFRpbVMxZUp1SDRnZFdXaFlSTkJNcUIzNGI4ZVJ6TXV3U1pVWkoKSHY4Zlo5WWx0ZlhMTE94bU1rZG1Sb3NrdE5tQW5EdnhKeGdWY0pVK2ZDQzIvR2d4dlpyM1NQSVYwQnREaWlSMApScS9ZdERpaVNadTZPQit6RkZRelJnSm41RGpscThLdFExV1I3MitMMFFCNkdCcEVBZGpFNHdxMFpabXg4WHBuCkFhTDRsZkpQYlpPR2JVR1pUNGJWTEFKb1dtT1J3MFhod3BWbkw1UGp2SW1INHpwTzlTZHY0S3lsVk1OUlhHdWQKTjAwZ3lzQUl3UUJHYS9FN056eE94SVJqNTBVREFUS2JOamlQbms2bmpVcUp1bUhyQXNaVFR6bE83UDJUcFcycQpxS3JxZC9ydjBHdldMVU03MnNFTGp5czNxTFo2UkdscEFTdUxIQ3BXTFZ5OHB5L3BXUmR4Q1FZN2F3RFlsUU4yCm9XSHRUVjdNNjJYaVBhMjR5dUxLN0JZU3c1OFRNc3FnRnVra3FXSjlmYmFnQThROXArOEdvSzdCZklzQ0F3RUEKQVFLQ0FnQUpRSE92TVdNS0U0alhYME90bG5IalA4K3BRMHdTSGhDODFqcWxkQmVXME45TlB5ZmJucWorWWdzVgpud081QlIxbHdNU1ZKTjI5WUVMOXZHZ2dtaUhFakpYZHowTTdQV1hNQkEzUDM5cm43V1c0R3plSnhQMnlSa1FuCnJhMVNzOVZnYlNjUzQ3WEJBK3hYOGU1RWdQKzcyTGNwZ0J6cE1XTkxURFZBOUpOOFkvRnZsMWcxVFR5V2tBc2QKaGZFbkRnZjMxUmpLZkJQeUprMmJMYjhvT29sUS95TzVuN05WUkp3bHgzeTFwNW9DOUtDVGpLME5qenFZcEpkdgpPWmtjd2JPd1hMN3BxdGVac2FRa0VmRjV2TjNKRW5EaFJLVkxvNEhBcWpBZm96dVgybkw1R2REaWVnUktIMDMzCmtmbTluMzFsR21rbE1pUjkzenN0bFZuMGlLSFp6OXBLY3dpZWxjZ0FtSWluM2QxbkNweXNoSUpyaERxZm9QRDYKM2ZzNmNCRGlhdDBPdCtablFGekR5ZHdQUk80b2xHUnl4Q2RtTmJCOUNWM2JILzlHTVl0QW1JSFRYVU9aT3prbAovQmgwVkYrUlJJVFpya21lUVdNNVlVeU8wNEEzaVZ6bFhlYWRuZW04NWlBeXAzR01UYTdxMjg3QWtmaFY2U3pMCmQxcVR4UWU5ZlI2MzVaaGV5NkJuTEUyd1RGWVhvOUJTSVNWWW9rYi9RTTliMVBLcEh6TXFaSVlHU3c2OGhQMkkKRWJtRmN2U0JYSkZsa2R4cG5ENTI4aXNualNPcmJ5V1lIYXZBL1ZxdUVSRnNZeUkxRXAzd3lBRjNsQjBOTWpWcwoyMWFHVVBFUEhyR0RackFlL1UwRm9mUUVoNTdUcnRmS2NUeGNzY2dUbUpGTXZMWVVjUUtDQVFFQThYU3dNMVlhCjNUa2x2a0NuQWhKcnUrVHNReVlyb244dkxLaVB3ZTFlUTRmbS9EaDNXdkVWRHd2ZXA0cXR2Q3psVDJBM1M0blcKSHhRM3FhcURGai8zY1pBdmlFV2F0Y1E3eVl3OUNhaGtMS0xXWlpDRlUxbENhaFFBSmFvM25KWUFBcXJPdk5pMgp5WVdtQlhRZEFoQktWZS9jandibTd0R2xML0hxbmdnUFVXamNkNVBwZXFsTXZ2cUYwRitBbUtvUHhkOE1QaVFHCkgvV29mZndqaFNHOW1nRWJiV25rU1RRelZYZUJqcVNoWUFHQkxnZ2l4SDdzcDA5VnJnV1hKVStiTUpDMERzZ1YKMUNMRXQ4U3BUbXBJM3o0QjhlN2xncHJuYWtYRERxN01Gd0Zzb0FPS3B2b0lBYkthRVJEdGtvMWozZ2dUKzJXdgpqZ3lFWUFTVktwdTB6UUtDQVFFQXhCeTJITzhMMXYyMzF2NGpPWHNmQlpTNk52dFNTekRyc3czanlxUmRSZmJRCmxiZUZVekJHdjFOMnJyL0lTTmdKSlQ2UXdidS9vYUk0NzU1NXZQbWwyb3dkTG1OVFVUKzNMNXIwSnFhTngvZkEKTU9EVURBeGxYaDY4cmx0MUdiRTkwRXBka2tVQUNsL1F5STQyVndEVllib3N0ZUc1dmZ3UHUreWRoSnBGaWRZNApCc2lGYTN3WWtrZGRmdWZKZFltM25zODVqY1FQME9kVS9MSUdXWXZWSHRNOEZjWm5oTVpqbUFpTUpsTGhTYkdvCkRqQzFacmtXbVl4MXloQUhjWmtFdlJhWWNidlJkNXFVRkwyWS8wNktQMXVGQSt3S3lFL3ovZ0hYaDROSkJUR0IKbEdzUU1xL3o0Nm5ITWJMa1ZFeGFlUmtBc0lzK0JXWkxCbXp2WnBBMnR3S0NBUUVBbENUMkh1bExua1A3NWxrZwpudUxTZXZ3Z0Fhc2Z4cG1tUmc0OTljdy9zOHRrYTRmeG96aWJwUm14U0xhTGxoTXR0cC9nRFZiS3ExTHFQQTFFClZKaDJwNVRCdFNpUG5jcUNyRXlBL3JYMGtIWndlT3hOQVRDWTBTRG9Yak9yMzBVaFNJR29TckhrcEl4OXFvYnQKYldDMVd6ako2RzloclZHdnVsVUJrR2g5allON0VWc05PNWM0WVV5d1lZTFhFZFAxelgvbXNSSEZPRUt2V0cwbApGZi8zcHMvYkZpeU1SbVhpd1NPTHVBdEdmL01zWVNQWXdScm05RmgyeDBqaXpaK2tKZzRDaTdjenZXNS9xQWpmCm9COFNDdmF1bHRQdXVVMTFndnkraXZtd2VzVUM4c0o1aGEyTzBBdlcvM1dWYmYrV01KcGdPRFRSbTZRT2JDTWoKcW5yU1dRS0NBUUFYbi9uVVhIdkpwNEQ1Rmw1NTh6b1dld2Mvem1Eb2kva285ZGhtTmd6Q2Urdyt6UC96dUpJZApSRm04elgrOFBzSkRTVms0N1h3MVpZeUVXVXdERnZRQzh2UWsvWFF4Q29MdjZqUFZZQ1VlWE5zN1NDcGpWUzcwCityRHlORFJVSndUeVRiTWVCcy90Y0FOLzFabjRPeko1ZG1zaWNoSGxNRE5aQ1RVa24wMFhRTVk1RXZqM3JOaHMKN3NuMW1zaXJMeTcrbzZva1NPVTYzbE5mcWJhWUhQOU1tbGZYcTdJV3phdDd5alBQL2hZRHdiSWtHM3dPNXVjeApFam15WU9IMHJtRml3aEVWU25IK2ZaR3ZPZlB2ZGErejJEdWE4Rm1RTGdtUHBQc282UWpuNWtIYzlsVGFObFlrCksvVENLUEhXc2VnSVJKblBxc2FLOGZyQnlHZkNyRWJiQW9JQkFETkh5NjRXb3l4SEt4ajgyV0RzQ2RmTmxKN3YKY1lETXY4RmF1a3lVMDhPWGRhSFB3d0QrZnpMaVVzdUdLNURlNWdCZFFIR1MyOE15eWJwTmFrZVdNamVkY21yNwozZDJnaFBQZFZ2MTI3UlEydVk4L3RBdTh6M3VjbUViRURpVjFYN3MyaE5Odk1OVnJPUHMwZDNsMzdPeGREL0lOCjd6N0RKcFY2UmFsUngyTmdqNWJ6cHF0aGkxbDhiZFJLTE9aRlBuZjZhb09GVlp1UER6OUZIZGR0dXJBNzU1V3cKOUNYQi8zdytsZ1N1VVpYYjRQQngveTZZTTVyNWpWQzNHWC9Ydmk4RGJ1QnlqSXJHdUcwdkhyYXEzUlBiNW1VTQpERmNaZFJ1ZnBNd1g0TWNNUENSOFNBNTZKQmpSZDg3UzZRNWx2VGowRy9RSFdiUG0yUWJTd0R4Qml5RT0KLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS0K"
      }
    },
    {
      "jinojoe": {
        "receipt_email_address": "jinojoe@gmail.com",
        "sftp_username": "jino",
        "sftp_port": 22,
        "sftp_password": "password",
        "sftp_hostname": "s-1369b93de4224908a.server.transfer.ap-south-1.amazonaws.com",
        "sftp_encoded_private_key": "LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlKS0FJQkFBS0NBZ0VBdVBocmJ0TUkzRzdQOXFMOXVVRVhaN0JCcjFLNjZzUzJxT3QvbGJDOFNJSnVJQTRrCnhBLzZ4Vm84NDVTazhUb2k1aFc4ckl6TWVheWZLUWdjZ1lFTFRJL2kwcUxWamdkRURlTzNOV1JXTTVFN1VJTXMKbDR4Z0tFdDVnNEJRQUJjZmFrQ2Y4ZGtBaG5Ud050aFgrSElLRC9kOCtKb3h4WE4yNnBBTmhnQUkwb0RZY21UaQpoN0F0UjczbndacisvQWdMdEN4b1Rkb1VLcWo3UmhSOHk4N0RoRlMyZmlpdlV1OFY1YnNvT3hDdndxcUdwdWxtCkt5R1g5ekNVL2x6T0M4Y3VQUEw2dU1ISE1BeFRpbVMxZUp1SDRnZFdXaFlSTkJNcUIzNGI4ZVJ6TXV3U1pVWkoKSHY4Zlo5WWx0ZlhMTE94bU1rZG1Sb3NrdE5tQW5EdnhKeGdWY0pVK2ZDQzIvR2d4dlpyM1NQSVYwQnREaWlSMApScS9ZdERpaVNadTZPQit6RkZRelJnSm41RGpscThLdFExV1I3MitMMFFCNkdCcEVBZGpFNHdxMFpabXg4WHBuCkFhTDRsZkpQYlpPR2JVR1pUNGJWTEFKb1dtT1J3MFhod3BWbkw1UGp2SW1INHpwTzlTZHY0S3lsVk1OUlhHdWQKTjAwZ3lzQUl3UUJHYS9FN056eE94SVJqNTBVREFUS2JOamlQbms2bmpVcUp1bUhyQXNaVFR6bE83UDJUcFcycQpxS3JxZC9ydjBHdldMVU03MnNFTGp5czNxTFo2UkdscEFTdUxIQ3BXTFZ5OHB5L3BXUmR4Q1FZN2F3RFlsUU4yCm9XSHRUVjdNNjJYaVBhMjR5dUxLN0JZU3c1OFRNc3FnRnVra3FXSjlmYmFnQThROXArOEdvSzdCZklzQ0F3RUEKQVFLQ0FnQUpRSE92TVdNS0U0alhYME90bG5IalA4K3BRMHdTSGhDODFqcWxkQmVXME45TlB5ZmJucWorWWdzVgpud081QlIxbHdNU1ZKTjI5WUVMOXZHZ2dtaUhFakpYZHowTTdQV1hNQkEzUDM5cm43V1c0R3plSnhQMnlSa1FuCnJhMVNzOVZnYlNjUzQ3WEJBK3hYOGU1RWdQKzcyTGNwZ0J6cE1XTkxURFZBOUpOOFkvRnZsMWcxVFR5V2tBc2QKaGZFbkRnZjMxUmpLZkJQeUprMmJMYjhvT29sUS95TzVuN05WUkp3bHgzeTFwNW9DOUtDVGpLME5qenFZcEpkdgpPWmtjd2JPd1hMN3BxdGVac2FRa0VmRjV2TjNKRW5EaFJLVkxvNEhBcWpBZm96dVgybkw1R2REaWVnUktIMDMzCmtmbTluMzFsR21rbE1pUjkzenN0bFZuMGlLSFp6OXBLY3dpZWxjZ0FtSWluM2QxbkNweXNoSUpyaERxZm9QRDYKM2ZzNmNCRGlhdDBPdCtablFGekR5ZHdQUk80b2xHUnl4Q2RtTmJCOUNWM2JILzlHTVl0QW1JSFRYVU9aT3prbAovQmgwVkYrUlJJVFpya21lUVdNNVlVeU8wNEEzaVZ6bFhlYWRuZW04NWlBeXAzR01UYTdxMjg3QWtmaFY2U3pMCmQxcVR4UWU5ZlI2MzVaaGV5NkJuTEUyd1RGWVhvOUJTSVNWWW9rYi9RTTliMVBLcEh6TXFaSVlHU3c2OGhQMkkKRWJtRmN2U0JYSkZsa2R4cG5ENTI4aXNualNPcmJ5V1lIYXZBL1ZxdUVSRnNZeUkxRXAzd3lBRjNsQjBOTWpWcwoyMWFHVVBFUEhyR0RackFlL1UwRm9mUUVoNTdUcnRmS2NUeGNzY2dUbUpGTXZMWVVjUUtDQVFFQThYU3dNMVlhCjNUa2x2a0NuQWhKcnUrVHNReVlyb244dkxLaVB3ZTFlUTRmbS9EaDNXdkVWRHd2ZXA0cXR2Q3psVDJBM1M0blcKSHhRM3FhcURGai8zY1pBdmlFV2F0Y1E3eVl3OUNhaGtMS0xXWlpDRlUxbENhaFFBSmFvM25KWUFBcXJPdk5pMgp5WVdtQlhRZEFoQktWZS9jandibTd0R2xML0hxbmdnUFVXamNkNVBwZXFsTXZ2cUYwRitBbUtvUHhkOE1QaVFHCkgvV29mZndqaFNHOW1nRWJiV25rU1RRelZYZUJqcVNoWUFHQkxnZ2l4SDdzcDA5VnJnV1hKVStiTUpDMERzZ1YKMUNMRXQ4U3BUbXBJM3o0QjhlN2xncHJuYWtYRERxN01Gd0Zzb0FPS3B2b0lBYkthRVJEdGtvMWozZ2dUKzJXdgpqZ3lFWUFTVktwdTB6UUtDQVFFQXhCeTJITzhMMXYyMzF2NGpPWHNmQlpTNk52dFNTekRyc3czanlxUmRSZmJRCmxiZUZVekJHdjFOMnJyL0lTTmdKSlQ2UXdidS9vYUk0NzU1NXZQbWwyb3dkTG1OVFVUKzNMNXIwSnFhTngvZkEKTU9EVURBeGxYaDY4cmx0MUdiRTkwRXBka2tVQUNsL1F5STQyVndEVllib3N0ZUc1dmZ3UHUreWRoSnBGaWRZNApCc2lGYTN3WWtrZGRmdWZKZFltM25zODVqY1FQME9kVS9MSUdXWXZWSHRNOEZjWm5oTVpqbUFpTUpsTGhTYkdvCkRqQzFacmtXbVl4MXloQUhjWmtFdlJhWWNidlJkNXFVRkwyWS8wNktQMXVGQSt3S3lFL3ovZ0hYaDROSkJUR0IKbEdzUU1xL3o0Nm5ITWJMa1ZFeGFlUmtBc0lzK0JXWkxCbXp2WnBBMnR3S0NBUUVBbENUMkh1bExua1A3NWxrZwpudUxTZXZ3Z0Fhc2Z4cG1tUmc0OTljdy9zOHRrYTRmeG96aWJwUm14U0xhTGxoTXR0cC9nRFZiS3ExTHFQQTFFClZKaDJwNVRCdFNpUG5jcUNyRXlBL3JYMGtIWndlT3hOQVRDWTBTRG9Yak9yMzBVaFNJR29TckhrcEl4OXFvYnQKYldDMVd6ako2RzloclZHdnVsVUJrR2g5allON0VWc05PNWM0WVV5d1lZTFhFZFAxelgvbXNSSEZPRUt2V0cwbApGZi8zcHMvYkZpeU1SbVhpd1NPTHVBdEdmL01zWVNQWXdScm05RmgyeDBqaXpaK2tKZzRDaTdjenZXNS9xQWpmCm9COFNDdmF1bHRQdXVVMTFndnkraXZtd2VzVUM4c0o1aGEyTzBBdlcvM1dWYmYrV01KcGdPRFRSbTZRT2JDTWoKcW5yU1dRS0NBUUFYbi9uVVhIdkpwNEQ1Rmw1NTh6b1dld2Mvem1Eb2kva285ZGhtTmd6Q2Urdyt6UC96dUpJZApSRm04elgrOFBzSkRTVms0N1h3MVpZeUVXVXdERnZRQzh2UWsvWFF4Q29MdjZqUFZZQ1VlWE5zN1NDcGpWUzcwCityRHlORFJVSndUeVRiTWVCcy90Y0FOLzFabjRPeko1ZG1zaWNoSGxNRE5aQ1RVa24wMFhRTVk1RXZqM3JOaHMKN3NuMW1zaXJMeTcrbzZva1NPVTYzbE5mcWJhWUhQOU1tbGZYcTdJV3phdDd5alBQL2hZRHdiSWtHM3dPNXVjeApFam15WU9IMHJtRml3aEVWU25IK2ZaR3ZPZlB2ZGErejJEdWE4Rm1RTGdtUHBQc282UWpuNWtIYzlsVGFObFlrCksvVENLUEhXc2VnSVJKblBxc2FLOGZyQnlHZkNyRWJiQW9JQkFETkh5NjRXb3l4SEt4ajgyV0RzQ2RmTmxKN3YKY1lETXY4RmF1a3lVMDhPWGRhSFB3d0QrZnpMaVVzdUdLNURlNWdCZFFIR1MyOE15eWJwTmFrZVdNamVkY21yNwozZDJnaFBQZFZ2MTI3UlEydVk4L3RBdTh6M3VjbUViRURpVjFYN3MyaE5Odk1OVnJPUHMwZDNsMzdPeGREL0lOCjd6N0RKcFY2UmFsUngyTmdqNWJ6cHF0aGkxbDhiZFJLTE9aRlBuZjZhb09GVlp1UER6OUZIZGR0dXJBNzU1V3cKOUNYQi8zdytsZ1N1VVpYYjRQQngveTZZTTVyNWpWQzNHWC9Ydmk4RGJ1QnlqSXJHdUcwdkhyYXEzUlBiNW1VTQpERmNaZFJ1ZnBNd1g0TWNNUENSOFNBNTZKQmpSZDg3UzZRNWx2VGowRy9RSFdiUG0yUWJTd0R4Qml5RT0KLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS0K"
      }
    }
  ]
}

```

```py
import paramiko
import base64
import io
import json
import gnupg
import re
import os
import pathlib
import boto3
import urllib

key_store_name = os.environ.get('KEY_STORE_BUCKET_NAME')
region_name = "ap-southeast-1"                                              # os.environ.get('REGION_NAME')
allowed_agency_list_secret_name = "sm-bca-cnxcp-fhq-sit/agency-information" # os.environ.get('ALLOWED_AGENCY_LIST_SECRET_NAME')

class SecretManager:
    def __init__(self, region_name):
        self.client = boto3.client('secretsmanager', region_name=region_name)

    def retrieve_data(self, secret_name):
        get_secret_value_response = self.client.get_secret_value(SecretId=secret_name)
        secret = get_secret_value_response['SecretString']
        print(secret)
        return json.loads(secret)
    
class GnuPGHandler:

    TEMP_DIRECTORY = "tmp"
    def __init__(self, recipient_email):
        self.recipient_email = recipient_email
        self.gpg = gnupg.GPG(gnupghome=os.path.join("/", self.TEMP_DIRECTORY + "/"), gpgbinary='/opt/python/gpg', verbose=True)

    def generate_gpg_key(self):
        input_data = self.gpg.gen_key_input(name_email=self.recipient_email)
        key_gen_result = self.gpg.gen_key(input_data)
        private_key_data = self.gpg.export_keys(key_gen_result.fingerprint, secret=True)
        public_key_data = self.gpg.export_keys(key_gen_result.fingerprint)
        export_file_name = os.path.join("/", self.TEMP_DIRECTORY + "/") + re.split(r'@', self.recipient_email)[0] + ".asc"

        with open(export_file_name, 'w') as f:
            f.write(private_key_data)
            f.write(public_key_data)

        return export_file_name

    def encrypt_file_with_gpg_key(self, key_file, input_file):
        if self.is_valid_file_for_encryption(input_file):
            return {
                "encryption_successful": False,
                "status_message": "Filetype is invalid"
            }
        else:
            key_data = open(key_file).read()
            # key_data = base64.b64decode(key_file)
            self.gpg.import_keys(key_data)
            output_file = input_file + ".gpg"
            status = self.gpg.encrypt_file(input_file, recipients=[self.recipient_email], output=output_file, always_trust=True)
            return {
                "encryption_successful": status.ok,
                "status_message": status.status,
                "output_file": output_file
            }

    def decrypt_file_with_gpg_key(self, key_file, encrypted_file):
        if self.is_valid_file_for_encryption(encrypted_file):
            key_data = open(key_file).read()
            self.gpg.import_keys(key_data)
            output_file = os.path.splitext(encrypted_file)[0]
            status = self.gpg.decrypt_file(encrypted_file, output=output_file)
            return {
                "decryption_successful": status.ok,
                "status_message": status.status,
                "output_file": output_file
            }
        else:
            return {
                "decryption_successful": False,
                "status_message": "Filetype is invalid"
            }

    def is_valid_file_for_encryption(self, file_path):
        file_extension = pathlib.Path(file_path).suffix
        if file_extension in ['.asc', '.gpg', '.pgp']:
            return True
        else:
            return False

class S3EventInformation:
    def __init__(self, event, context):
        self.event = event
        self.context = context

    def get_event_name(self):
        return self.event['detail']['eventName']

    def get_event_bucket(self):
        return urllib.parse.unquote_plus(self.event['detail']['requestParameters']['bucketName'])
    
    def get_event_bucket_key(self):
        return urllib.parse.unquote_plus(self.event['detail']['requestParameters']['key'])


class S3Process:
    TEMP_DIRECTORY = "tmp"
    CHECKSUM_ALGORITHM = 'SHA256'

    def __init__(self, bucket: str, key: str):
        self.bucket = bucket
        self.key = key
        self.s3 = boto3.resource('s3')
        self.s3_client = boto3.client('s3')
        self.parent_path = pathlib.PurePath(self.key).parent
        self.child_name = pathlib.PurePath(self.key).name

    def download(self) -> str:
        download_location = os.path.join("/", self.TEMP_DIRECTORY + "/") + self.child_name
        self.s3.meta.client.download_file(self.bucket, self.key, download_location)
        return download_location

    def agent_key_download(self, bucket: str, agent_name: str) -> str:
        file_name = agent_name + ".asc"
        download_location = os.path.join("/", self.TEMP_DIRECTORY + "/") + file_name
        self.s3.meta.client.download_file(bucket, file_name, download_location)
        return download_location
    
    def delete(self, destination_bucket: str = None):
        target_bucket = destination_bucket if destination_bucket is not None else self.bucket
        return self.s3_client.delete_object(Bucket=target_bucket, Key=self.key)

    def upload(self, file_path: str, destination_bucket: str = None, destination_path: str = None):
        target_bucket = destination_bucket if destination_bucket is not None else self.bucket
        destination_path = destination_path if destination_path is not None else file_path
        return self.s3.meta.client.upload_file(file_path, target_bucket, destination_path)

    def create_new_tag(self, t_name: str, t_value: str, t_key: str = None):
        tagging = {'TagSet': [{'Key': t_name, 'Value': t_value}]}
        t_key = t_key if t_key is not None else self.key
        return self.s3_client.put_object_tagging(Bucket=self.bucket, Key=t_key, Tagging=tagging)

    def object_state(self) -> bool:
        return 'Contents' in self.s3_client.list_objects(Bucket=self.bucket, Prefix=self.key)

    def update_tags(self, destination_bucket: str = None, updation_tags: list = None):
        target_bucket = destination_bucket if destination_bucket is not None else self.bucket
        updation_tag_lists = updation_tags if updation_tags is not None else self.get_tags()
        return self.s3_client.put_object_tagging(Bucket=target_bucket, Key=self.key, Tagging={'TagSet': updation_tag_lists})

    def log_poster(self, event: str, state: str) -> str:
        return json.dumps({'event': event, 'bucket': self.bucket, 'fileName': self.key, 'processState': state})

    def ignore_path_position(self, path_position: int) -> str:
        data = re.split(r'/', self.key)
        return ("/".join(data[path_position:]))

    def copy(self, destination_bucket: str, custom_location: str = None):
        target_path = custom_location if custom_location is not None else self.key
        source = {'Bucket': self.bucket, 'Key': self.key}
        return self.s3_client.copy_object(
            CopySource=source,
            Bucket=destination_bucket,
            Key=target_path,
            TaggingDirective='COPY',
            ChecksumAlgorithm=self.CHECKSUM_ALGORITHM
        )


def decode_base64_private_key(encoded_key):
    try:
        # base64 -w 0 < eno > my_ssh_key_base64
        decoded_bytes = base64.b64decode(encoded_key)
        return decoded_bytes.decode('utf-8')
    except Exception as e:
        return None

def upload_to_sftp(host, username, private_key_path, remote_path, local_path):
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        private_key = paramiko.RSAKey.from_private_key(file_obj=io.StringIO(private_key_path), password=None)
        # private_key = paramiko.RSAKey(filename=private_key_path)
        ssh.connect(host, username=username, pkey=private_key)
        sftp = ssh.open_sftp()
        sftp.put(local_path, remote_path)
        sftp.close()
        ssh.close()
    except Exception as e:
        print(e)

def lambda_handler(event, context):
    # event_information = S3EventInformation(event, context)
    # event_bucket = event_information.get_event_bucket()
    # key = event_information.get_event_bucket_key()
    # s3_processor = S3Process(event_bucket, key)

    event_bucket = "demo-sit-cp"
    key = "SFTP/OUT/jinojoe/A_B/print.odt"
    s3_processor = S3Process(event_bucket, key)

    local_path = s3_processor.download()
    remote_path = s3_processor.ignore_path_position(2)
    retrieve_secret_data = SecretManager(region_name)
    
    agency_details_list = retrieve_secret_data.retrieve_data(allowed_agency_list_secret_name)
    agency_details = agency_details_list['agencies']
    common_key_bucket_location = agency_details_list['common-pgp-key-bucket']
    agent_name = agency_details_list['common-agent-name']
    pgp_email_receipt = agency_details_list['common-encryption-mail']
                    
    pgp_encryption = GnuPGHandler(pgp_email_receipt)

    if s3_processor.object_state():
        if (pgp_encryption.is_valid_file_for_encryption(key)):
            print("condition")
        else:
            decryption_agent_key_download = S3Process(common_key_bucket_location, agent_name + ".asc").download()
            pgp_encryption_status = pgp_encryption.encrypt_file_with_gpg_key(decryption_agent_key_download, local_path)
            encrypt_local_path = os.path.dirname(remote_path) + "/" + os.path.basename(pgp_encryption_status['output_file'])
            for agency in agency_details:
                for key, value in agency.items():
                    pgp_email_receipt = agency_details[0][key]['receipt_email_address']
                    sftp_username = agency_details[0][key]['sftp_username']
                    sftp_port = agency_details[0][key]['sftp_port']
                    sftp_password = agency_details[0][key]['sftp_password']
                    sftp_hostname = agency_details[0][key]['sftp_hostname']
                    sftp_encoded_private_key = agency_details[0][key]['sftp_encoded_private_key']
                    sftp_private_key = decode_base64_private_key(sftp_encoded_private_key)

                    upload_to_sftp(sftp_hostname, sftp_username, sftp_private_key, encrypt_local_path, pgp_encryption_status['output_file'])

            # s3_processor.delete()
            os.remove(pgp_encryption_status['output_file'])  
    else:
        s3_processor.log_poster(event_bucket, "unknown events or agency details")

    os.remove(local_path)   

```
